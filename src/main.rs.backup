use anyhow::Result;
use crossterm::{
    cursor, execute,
    terminal::{self, Clear, ClearType},
};
use glam::{Mat4, Vec2, Vec3};
use std::io::{stdout, Write, BufWriter};
use wgpu::util::DeviceExt;

mod camera;
mod geometry;
mod material;
mod renderer;
mod world_gen;

use camera::Camera;
use geometry::Geometry;
use material::Material;
use renderer::Renderer;
use world_gen::generate_chunk_geometry;

fn get_terminal_size() -> (u32, u32) {
    match terminal::size() {
        Ok((cols, rows)) => (cols as u32, rows as u32),
        Err(_) => (80, 24), // fallback
    }
}

#[repr(C)]
#[derive(Debug, Copy, Clone, bytemuck::Pod, bytemuck::Zeroable)]
struct Uniforms {
    view_proj: [[f32; 4]; 4],
}

impl Uniforms {
    fn new() -> Self {
        Self {
            view_proj: Mat4::IDENTITY.to_cols_array_2d(),
        }
    }

    fn update_view_proj(&mut self, camera: &Camera) {
        self.view_proj = camera.get_proj_view_matrix().to_cols_array_2d();
    }
}

struct MinecraftTTY {
    renderer: Renderer,
    camera: Camera,
    geometries: Vec<Geometry>,
    material: Material,
    uniform_buffer: wgpu::Buffer,
    uniform_bind_group: wgpu::BindGroup,
    uniforms: Uniforms,
    terminal_width: u32,
    terminal_height: u32,
}

impl MinecraftTTY {
    async fn new() -> Result<Self> {
        let (terminal_width, terminal_height) = get_terminal_size();
        let renderer = Renderer::new(terminal_width, terminal_height).await?;
        
        let camera = Camera::new(
            terminal_width as f32 / terminal_height as f32,
            Vec3::new(4.0, 6.0, 4.0), // Position camera above and away from origin
        );

        let uniforms = Uniforms::new();
        let uniform_buffer = renderer.device.create_buffer_init(&wgpu::util::BufferInitDescriptor {
            label: Some("Uniform Buffer"),
            contents: bytemuck::cast_slice(&[uniforms]),
            usage: wgpu::BufferUsages::UNIFORM | wgpu::BufferUsages::COPY_DST,
        });

        let material = Material::new(&renderer.device, &uniform_buffer)?;
        let uniform_bind_group = material.create_bind_group(&renderer.device, &uniform_buffer);

        // Generate some chunks closer to origin
        let mut geometries = Vec::new();
        for x in 0..2 {
            for z in 0..2 {
                let chunk_pos = Vec2::new(x as f32, z as f32);
                let geometry = generate_chunk_geometry(&renderer.device, &renderer.queue, chunk_pos)?;
                geometries.push(geometry);
            }
        }

        Ok(Self {
            renderer,
            camera,
            geometries,
            material,
            uniform_buffer,
            uniform_bind_group,
            uniforms,
            terminal_width,
            terminal_height,
        })
    }

    fn handle_input(&mut self) -> Result<bool> {
        use crossterm::event::{self, Event, KeyCode, KeyEvent};

        // Use non-blocking poll with very short timeout
        match event::poll(std::time::Duration::from_millis(0)) {
            Ok(true) => {
                match event::read() {
                    Ok(Event::Key(KeyEvent { code, .. })) => {
                        match code {
                            KeyCode::Char('x') | KeyCode::Esc => return Ok(false),
                            KeyCode::Char('w') | KeyCode::Up => self.camera.move_forward(0.5),
                            KeyCode::Char('s') | KeyCode::Down => self.camera.move_forward(-0.5),
                            KeyCode::Char('a') | KeyCode::Left => self.camera.move_right(-0.5),
                            KeyCode::Char('d') | KeyCode::Right => self.camera.move_right(0.5),
                            KeyCode::Char('q') => self.camera.move_up(-0.5),
                            KeyCode::Char('e') => self.camera.move_up(0.5),
                            KeyCode::Char('h') => self.camera.rotate_y(-10.0),
                            KeyCode::Char('l') => self.camera.rotate_y(10.0),
                            KeyCode::Char('j') => self.camera.rotate_x(10.0),
                            KeyCode::Char('k') => self.camera.rotate_x(-10.0),
                            _ => {}
                        }
                    }
                    Ok(_) => {} // Other events
                    Err(_) => {} // Ignore input errors
                }
            }
            Ok(false) => {} // No input available
            Err(_) => {} // Ignore polling errors
        }
        Ok(true)
    }

    fn render(&mut self) -> Result<()> {
        // Update uniforms
        self.uniforms.update_view_proj(&self.camera);
        self.renderer.queue.write_buffer(
            &self.uniform_buffer,
            0,
            bytemuck::cast_slice(&[self.uniforms]),
        );

        // Render to texture
        let mut encoder = self.renderer.device.create_command_encoder(&wgpu::CommandEncoderDescriptor {
            label: Some("Render Encoder"),
        });

        {
            let mut render_pass = encoder.begin_render_pass(&wgpu::RenderPassDescriptor {
                label: Some("Render Pass"),
                color_attachments: &[Some(wgpu::RenderPassColorAttachment {
                    view: &self.renderer.texture_view,
                    resolve_target: None,
                    ops: wgpu::Operations {
                        load: wgpu::LoadOp::Clear(wgpu::Color {
                            r: 0.4,
                            g: 0.7,
                            b: 1.0,
                            a: 1.0,
                        }),
                        store: wgpu::StoreOp::Store,
                    },
                })],
                depth_stencil_attachment: Some(wgpu::RenderPassDepthStencilAttachment {
                    view: &self.renderer.depth_texture_view,
                    depth_ops: Some(wgpu::Operations {
                        load: wgpu::LoadOp::Clear(1.0),
                        store: wgpu::StoreOp::Store,
                    }),
                    stencil_ops: None,
                }),
                occlusion_query_set: None,
                timestamp_writes: None,
            });

            render_pass.set_pipeline(&self.material.render_pipeline);
            render_pass.set_bind_group(0, &self.uniform_bind_group, &[]);

            for geometry in &self.geometries {
                render_pass.set_vertex_buffer(0, geometry.vertex_buffer.slice(..));
                render_pass.set_index_buffer(geometry.index_buffer.slice(..), wgpu::IndexFormat::Uint16);
                render_pass.draw_indexed(0..geometry.index_count, 0, 0..1);
            }
        }

        self.renderer.queue.submit(std::iter::once(encoder.finish()));

        // Copy to CPU and display in terminal
        pollster::block_on(self.present_to_terminal())?;

        Ok(())
    }

    async fn present_to_terminal(&self) -> Result<()> {
        let pixels = self.renderer.read_pixels().await?;
        
        // Use a buffered writer for better performance
        let mut stdout = std::io::BufWriter::new(std::io::stdout());
        
        // Clear screen and move cursor to top-left
        write!(stdout, "\x1b[2J\x1b[H")?;

        // Track previous colors to avoid unnecessary ANSI code output
        let mut prev_fg: Option<[u8; 3]> = None;
        let mut prev_bg: Option<[u8; 3]> = None;

    async fn present_to_terminal(&self) -> Result<()> {
        let pixels = self.renderer.read_pixels().await?;
        
        // Use a buffered writer for better performance
        let mut stdout = std::io::BufWriter::new(std::io::stdout());
        
        // Clear screen and move cursor to top-left
        write!(stdout, "\x1b[2J\x1b[H")?;

        // Track previous colors to avoid unnecessary ANSI code output
        let mut prev_fg: Option<[u8; 3]> = None;
        let mut prev_bg: Option<[u8; 3]> = None;

        // Convert pixels to terminal characters
        // Each "▀" character represents 2 vertical pixels (top=foreground, bottom=background)
        // Process every 2 rows but only output one terminal line per iteration
        let mut y = 0;
        while y < self.terminal_height.min(self.renderer.height) {
            for x in 0..self.terminal_width.min(self.renderer.width) {
                // Get top pixel color (current row)
                let top_idx = ((y * self.renderer.width + x) * 4) as usize;
                
                // Get bottom pixel color (next row, or same if at bottom)
                let bottom_y = if y + 1 < self.renderer.height { y + 1 } else { y };
                let bottom_idx = ((bottom_y * self.renderer.width + x) * 4) as usize;
                
                if top_idx + 2 < pixels.len() && bottom_idx + 2 < pixels.len() {
                    let top_color = [pixels[top_idx], pixels[top_idx + 1], pixels[top_idx + 2]];
                    let bottom_color = [pixels[bottom_idx], pixels[bottom_idx + 1], pixels[bottom_idx + 2]];
                    
                    // Only set colors if they changed from previous pixel
                    if prev_fg.is_none() || prev_fg.unwrap() != top_color {
                        write!(stdout, "\x1b[38;2;{};{};{}m", top_color[0], top_color[1], top_color[2])?;
                        prev_fg = Some(top_color);
                    }
                    
                    if prev_bg.is_none() || prev_bg.unwrap() != bottom_color {
                        write!(stdout, "\x1b[48;2;{};{};{}m", bottom_color[0], bottom_color[1], bottom_color[2])?;
                        prev_bg = Some(bottom_color);
                    }
                    
                    write!(stdout, "▀")?;
                } else {
                    write!(stdout, " ")?;
                }
            }
            write!(stdout, "\n")?;
            y += 2; // Skip to next pair of rows
        }

        write!(stdout, "Camera: {:.1}, {:.1}, {:.1} | Controls: WASD/arrows=move, QE=up/down, HJKL=look, X/Esc=quit", 
            self.camera.position.x, 
            self.camera.position.y, 
            self.camera.position.z)?;

        stdout.flush()?;
        Ok(())
    }

    fn run(&mut self) -> Result<()> {
        terminal::enable_raw_mode()?;
        execute!(stdout(), terminal::EnterAlternateScreen, cursor::Hide)?;

        let result = loop {
            // Handle input first for better responsiveness
            if !self.handle_input()? {
                break Ok(());
            }
            
            if let Err(e) = self.render() {
                break Err(e);
            }
            
            std::thread::sleep(std::time::Duration::from_millis(16)); // ~60 FPS
        };

        execute!(stdout(), cursor::Show, terminal::LeaveAlternateScreen)?;
        terminal::disable_raw_mode()?;

        result
    }
}

fn main() -> Result<()> {
    env_logger::init();
    
    pollster::block_on(async {
        let mut app = MinecraftTTY::new().await?;
        app.run()
    })
}